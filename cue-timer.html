<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Cue Timer</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; background:#000; color:#fff; font-family: system-ui, -apple-system, "Hiragino Sans", sans-serif;
      user-select:none; -webkit-user-select:none;
    }
    .wrap{ padding:16px; display:flex; flex-direction:column; gap:12px; min-height:100vh; box-sizing:border-box; }
    .top{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    button{
      font-size:18px; padding:10px 14px; border-radius:10px; border:1px solid #444; background:#111; color:#fff;
    }
    button.primary{ border-color:#888; background:#1a1a1a; }
    button.danger{ border-color:#7a2d2d; background:#1a0f0f; }
    .grid{
      display:grid; grid-template-columns: 1fr 1fr; gap:12px;
    }
    .card{
      border:1px solid #333; border-radius:12px; padding:12px; background:#0b0b0b;
    }
    .label{ opacity:.75; font-size:13px; }
    .val{ font-size:26px; margin-top:6px; font-variant-numeric: tabular-nums; }
    textarea{
      width:100%; min-height:160px; background:#050505; color:#fff; border:1px solid #333; border-radius:12px;
      padding:12px; font-size:15px; line-height:1.5; box-sizing:border-box;
    }
    .hint{ opacity:.7; font-size:13px; line-height:1.5; }
    .overlay{
      position:fixed; inset:0; background:#000; display:none; align-items:center; justify-content:center;
      padding:24px; box-sizing:border-box;
    }
    .big{
      font-size:min(18vw, 120px);
      font-weight:800;
      text-align:center;
      line-height:1.05;
      word-break: break-word;
    }
    .sub{
      position:fixed; left:0; right:0; bottom:16px; text-align:center;
      font-size:18px; opacity:.8; font-variant-numeric: tabular-nums;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <button id="startBtn" class="primary">▶︎ Start</button>
      <button id="pauseBtn">⏸ Pause</button>
      <button id="resetBtn" class="danger">⟲ Reset</button>
      <button id="fsBtn">⛶ Fullscreen</button>
    </div>

    <div class="grid">
      <div class="card">
        <div class="label">経過時間</div>
        <div class="val" id="elapsed">00:00.0</div>
      </div>
      <div class="card">
        <div class="label">次のキューまで</div>
        <div class="val" id="toNext">--</div>
      </div>
      <div class="card" style="grid-column:1 / -1;">
        <div class="label">次のキュー</div>
        <div class="val" id="nextCue">--</div>
      </div>
    </div>

    <div class="card">
      <div class="label">キュー（開始からの秒数, 表示テキスト）</div>
      <textarea id="cueText">7, 1
15, 2
22.5, 目線左
30, ワイン出す</textarea>
      <div class="hint">
        書き方: <b>秒数, テキスト</b>（例: <b>22.5, 目線左</b>）<br/>
        秒数は開始からの<b>絶対秒</b>。順番は自動でソートされます。<br/>
        表示はキュー到達時に<b>大きく</b>出て、下に次キューまでの残り秒が出ます（無音）。
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="big" id="bigText"></div>
    <div class="sub" id="subText"></div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const startBtn = $("startBtn");
  const pauseBtn = $("pauseBtn");
  const resetBtn = $("resetBtn");
  const fsBtn = $("fsBtn");

  const elapsedEl = $("elapsed");
  const toNextEl = $("toNext");
  const nextCueEl = $("nextCue");

  const cueTextEl = $("cueText");

  const overlay = $("overlay");
  const bigText = $("bigText");
  const subText = $("subText");

  let cues = [];
  let running = false;

  let startPerf = 0;       // performance.now at start/resume
  let carried = 0;         // elapsed ms accumulated before current run
  let rafId = null;

  let nextIndex = 0;
  let showing = false;
  let showUntil = 0;       // perf time until overlay hides

  // Customize: how long to show each cue (ms)
  const SHOW_MS = 900;     // 0.9秒だけ表示（ここを変えると調整できる）

  function parseCues() {
    const lines = cueTextEl.value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const parsed = [];
    for (const line of lines) {
      // allow "7, text" or "7 text"
      const m = line.includes(",") ? line.split(",") : line.split(/\s+/);
      const t = parseFloat((m[0] || "").trim());
      const text = (m.slice(1).join(",").trim() || "").trim();
      if (!Number.isFinite(t) || t < 0 || !text) continue;
      parsed.push({ tSec: t, text });
    }
    parsed.sort((a,b)=>a.tSec-b.tSec);
    cues = parsed;
  }

  function fmt(ms) {
    const sec = ms / 1000;
    const m = Math.floor(sec / 60);
    const s = sec - m*60;
    const sInt = Math.floor(s);
    const tenths = Math.floor((s - sInt) * 10);
    return String(m).padStart(2,"0")+":"+String(sInt).padStart(2,"0")+"."+tenths;
  }

  function fmtToNext(ms) {
    if (!Number.isFinite(ms)) return "--";
    const sec = ms / 1000;
    if (sec < 0) return "00.0";
    if (sec < 10) return sec.toFixed(1);
    if (sec < 60) return sec.toFixed(1);
    return fmt(ms);
  }

  function nowElapsedMs() {
    if (!running) return carried;
    return carried + (performance.now() - startPerf);
  }

  function enterFullscreen() {
    // iOS Safari doesn't support true fullscreen reliably; but this helps on other browsers.
    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen().catch(()=>{});
  }

  function showCue(text, remainingMs) {
    showing = true;
    showUntil = performance.now() + SHOW_MS;
    bigText.textContent = text;
    subText.textContent = "次まで " + fmtToNext(remainingMs) + " 秒";
    overlay.style.display = "flex";
  }

  function hideCue() {
    showing = false;
    overlay.style.display = "none";
  }

  function resetRunState() {
    carried = 0;
    startPerf = performance.now();
    nextIndex = 0;
    hideCue();
  }

  function tick() {
    const e = nowElapsedMs();
    elapsedEl.textContent = fmt(e);

    // next cue
    const next = cues[nextIndex];
    if (next) {
      const nextMs = next.tSec * 1000;
      const remain = nextMs - e;
      toNextEl.textContent = fmtToNext(remain);
      nextCueEl.textContent = `${next.tSec}s : ${next.text}`;

      // fire cue
      if (remain <= 0) {
        // Determine remaining to the following cue for sub display
        const following = cues[nextIndex + 1];
        const remainToFollowing = following ? (following.tSec*1000 - e) : NaN;
        showCue(next.text, remainToFollowing);
        nextIndex++;
      }
    } else {
      toNextEl.textContent = "--";
      nextCueEl.textContent = "（キュー終了）";
    }

    // overlay auto-hide
    if (showing && performance.now() >= showUntil) hideCue();

    rafId = requestAnimationFrame(tick);
  }

  function start() {
    parseCues();
    if (!cues.length) {
      alert("キューが空です。例: 7, 1");
      return;
    }
    if (running) return;
    running = true;
    startPerf = performance.now();
    rafId = requestAnimationFrame(tick);
    // Try to keep screen awake (supported in some browsers)
    tryWakeLock();
  }

  function pause() {
    if (!running) return;
    running = false;
    carried = nowElapsedMs();
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    // keep overlay as-is; it will be hidden when resume ticks again
    releaseWakeLock();
  }

  function resetAll() {
    pause();
    resetRunState();
    elapsedEl.textContent = fmt(0);
    toNextEl.textContent = "--";
    nextCueEl.textContent = "--";
  }

  // Wake Lock (best-effort)
  let wakeLock = null;
  async function tryWakeLock() {
    try {
      if ("wakeLock" in navigator) {
        wakeLock = await navigator.wakeLock.request("screen");
      }
    } catch {}
  }
  async function releaseWakeLock() {
    try { if (wakeLock) await wakeLock.release(); } catch {}
    wakeLock = null;
  }

  // UI hooks
  startBtn.addEventListener("click", start);
  pauseBtn.addEventListener("click", pause);
  resetBtn.addEventListener("click", resetAll);
  fsBtn.addEventListener("click", enterFullscreen);

  // Tap overlay to hide immediately (assistant操作)
  overlay.addEventListener("click", hideCue);

  // Initial parse
  parseCues();
  resetAll();
})();
</script>
</body>
</html>